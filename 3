자료구조 중 하나인 링크드 리스트 (Linked List)

링크드 리스트 (Linked List) 구조
  1. 연결 리스트라고도 함
  2. 배열은 순차적으로 연결된 공간에 데이터를 나열하는 데이터 구조
  3. 링크드 리스트는 떨어진 곳에 존재하는 데이터를 화살표로 연결해서 관리하는 데이터 구조
  4. 본래 C언어에서는 주요한 데이터 구조이지만, 파이썬은 리스트 타입이 링크드 리스트의 기능을 모두 지원
  5. 노드 (Node) - 데이터 저장 단위 (데이터값, 포인터) 로 구성 , 포인터 (Pointer) - 각 노드 안에서, 다음이나 이전의 노드와의 연결 정보를 가지고 있는 공간

링크드 리스트 (Linked List)의 장점과 단점

  장점
    · 미리 데이터 공간을 할당하지 않아도 됨 ( 배열은 미리 데이터 공간을 할당 해야 함)
    
  단점
    · 연결을 위한 별도 데이터 공간이 필요하므로, 저장공간 효율이 높지 않음
    · 연결 정보를 찾는 시간이 필요하므로 접근 속도가 느림
    · 중간 데이터 삭제시, 앞뒤 데이터의 연결을 재구성해야 하는 부가적인 작업 필요



링크드 리스트 (Linked List)를 파이썬으로 구현해보기

class Node:
  def __init__(self, data, next = None):
    self.data = data
    self.next = next

node1 = Node(1)
node2 = Node(2)
node1.next = node2 # node1의 포인터가 node2를 가르킴
head = node1

# 링크드 리스트 (Linked List)로 데이터 추가하기
def add(data):
  node = head
  while node.next:
    node = node.next
  node.next = Node(data)

# 링크드 리스트 (Linked List)로 데이터 출력하기
node = head
while node.next:
  print (node.data)
  node = node.next
print (node.data)

# 링크드 리스트 (Linked List) 데이터 사이에 데이터를 추가
node3 = node(1.5)  # 데이터 1과 2 사이에 추가할 데이터
search = True
while search:
  if node.data = 1:
    search = False
  else:
    node = node.next
node_next = node.next
node.next = node3
node3.next = node_next

----------------------------------------------------------------------
링크드 리스트 (Linked List)를 파이썬 객체지향 프로그래밍으로 구현하기 (위에서 구현한 기능 모두 넣기)

class Node:
  def __init__(self, data, next = None):
    self.data = data
    self.next = next

class NodeMgmt:
  def __init__(self, data):
    self.head = Node(data)
  
  def add(self, data):
    if self.head = "":
      self.head = Node(data)
    else:
      node = self.head
      while node.next:
        node = node.next
      node.next = Node(data)
  
  def desc(self):
    node = self.head
    while node:
      print (node.data)
      node = node.next
  
  def delete(self, data):  # 특정 노드를 삭제하기
    if self.head == ""
      print ("해당 값을 가진 노드가 없습니다.")
      return
    
    if self.head.data == data::
      temp = self.head
      self.head - self.head.next
      del temp
    else:
      node = self.head
      while node.next:
        if node.next.data == data:
          temp = node.next
          node.next = node.next.next
          del temp
  
  def find(self. data):    # 특정 노드를 찾기
    if self.head.data == data:
      return self.head.data
    else:
      node = self.head
      while node.next:
        if node.next.data == data:
          print ("node.next.data")
        else:
          node = node.next
      print ("찾는 데이터가 없습니다")
    
    

linkedlist1 = NodeMgmt(0)
------------------------------------------------------------------------------------------

다양한 링크드 리스트 (Linked List) 구조
   
   · 더블 링크드 리스트 (Doubly linked list)
      - 이중 연결 리스트라고도 함
      - 양방향으로 연결되어 있어서 노드 탐색이 양쪽으로 모두 가능
 
 
 파이썬으로 더블 링크드 리스트 (Doubly linked list) 구현해보기
 
class Node:
  def __init__(self, data, prev = None, next = None):
    self.prev = prev
    self.data = data
    self.next = next
  
class NodeMgmt:
  def __init__(self, data):
    self.head = Node(data)
    self.tail = self.head
    
  def insert(self, data):
    if self.head == None:
      self.head = Node(data)
      self.tail = self.head
    else:
      node = self.head
      while node.next
        node = node.next
      new = Node(data)
      node.next = new
      new.prev = node
      self.tail = new
  
  def desc(self):
    node = self.head
    while node:
      print (node.data)
      node = node.next
  
  def search_from_head(self, data):
    node = self.head
    while node:
      if node.data == data:
        return node
      else:
        node = node.next
    return False

  def search_from_tail(self, data):
    node = self.tail
    while node:
      if node.data == data:
        return node
      else:
        node = node.prev
    return False

  def insert_before(self, data, before_data): # 특정 노드 앞에 추가하는 함수
    if self.head == None:
      self.head = Node(data)
      return True
    else:
      node = self.tail
      while node.data != before_data:
        node = node.prev
        if node == None:
          return False
      new = Node(data)
      before_new = node.prev
      
      before_new.next = new
      new.prev = before_new
      node.prev = new
      new.next = node
      return True
  
  def insert_next(self, data, next_data): # 특정 노드 뒤에 추가하는 함수
    if self.head == None:
      self.head = Node(data)
      return True
    else:
      node = self.head
      while node.data != next_data
        node = node.next
        if node == None:
          return False
      new = Node(data)
      next_new = node.next
      
      node.next = new
      new.prev = node
      new.next = next_new
      next_new.prev = new
      return True
      

double_linkdedlist = NodeMgmt(0)






















  
